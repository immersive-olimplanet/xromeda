<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Bottom Sound Wave</title>
<style>
  :root{
    --wave-height: 34vh;  /* 하단 웨이브 영역 높이 */
    --blur: 10px;         /* 부드러움(블러) */
    --opacity: 0.95;      /* 전체 투명도 */
  }

  body{
    margin:0;
    min-height:100vh;
    background:#000;      /* 어두울수록 screen 합성이 예쁨 */
    font-family: "Pretendard Variable", Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans KR", "Apple SD Gothic Neo", sans-serif;
    color:#fff;
  }

  .sound-wave-wrap{
    position:fixed;
    left:0; right:0; bottom:0;
    height:var(--wave-height);
    pointer-events:none;
    z-index:0;            /* 필요시 -1로 내려 UI 뒤에 배치 */
  }
  .sound-wave{
    position:absolute; inset:0;
    width:100%; height:100%; display:block;
    filter: blur(var(--blur));
    opacity: var(--opacity);
    mix-blend-mode: screen;  /* 밝게 합성 */
  }

  .mic-cta{
    position:fixed;
    left:50%; transform:translateX(-50%);
    bottom: calc(var(--wave-height) + 16px);
    pointer-events:auto; z-index:10;
    background:#ffffff10;
    border:1px solid #ffffff33;
    color:#fff;
    padding:10px 14px; border-radius:999px;
    backdrop-filter: blur(6px);
    font-weight:600; cursor:pointer;
  }
  .mic-cta.hide{ display:none; }
</style>
</head>
<body>

<button class="mic-cta" id="recordBtn" style="bottom:calc(var(--wave-height) + 60px)">🔴 녹음 시작</button>

<div class="sound-wave-wrap" aria-hidden="true">
  <canvas id="wave" class="sound-wave"></canvas>
</div>
<script>
let mediaRecorder, audioChunks = [], isRecording = false;

document.getElementById('recordBtn').addEventListener('click', async () => {
  if (!analyser) {
    alert('먼저 "마이크 비주얼 시작" 버튼을 눌러 주세요.');
    return;
  }

  if (!isRecording) {
    // 녹음 시작
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    mediaRecorder = new MediaRecorder(stream);
    mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
    mediaRecorder.onstop = () => {
      const blob = new Blob(audioChunks, { type: 'audio/webm' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'vrook_record.webm';
      a.click();
      URL.revokeObjectURL(url);
      audioChunks = [];
    };
    mediaRecorder.start();
    isRecording = true;
    document.getElementById('recordBtn').textContent = '⏹️ 녹음 정지';
  } else {
    // 녹음 종료
    mediaRecorder.stop();
    isRecording = false;
    document.getElementById('recordBtn').textContent = '🔴 녹음 시작';
  }
});
</script>
<script>
(() => {
  /** ===== 설정 ===== */
  const CONFIG = {
    layers: 3,                // 레이어 수
    baseAmp: 22,              // 기본 진폭(px)
    maxBoost: 80,             // 소리 최대 증폭량(px)
    speed: [0.85, 1.1, 1.5],  // 레이어별 속도
    alpha: [0.60, 0.48, 0.38] // 레이어별 투명도(캔버스 채움에 반영)
  };

  // 색: 기본(#FFC6C6) ↔ 반응(#FE4141)
  const BASE_HEX = "#ffffff";
  const ACTIVE_HEX = "#FE4141";

  const canvas = document.getElementById('wave');
  const ctx = canvas.getContext('2d');
  const btn = document.getElementById('micBtn');

  let w=0, h=0, time=0;
  let audioCtx, analyser, dataArray;
  let level=0, levelSmooth=0;

  function resize(){
    const rect = canvas.getBoundingClientRect();
    canvas.width  = Math.ceil(rect.width * devicePixelRatio);
    canvas.height = Math.ceil(rect.height * devicePixelRatio);
    ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
    w = rect.width; h = rect.height;
  }
  addEventListener('resize', resize, {passive:true});
  resize();

  async function initMic(){
    const stream = await navigator.mediaDevices.getUserMedia({audio:true});
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const src = audioCtx.createMediaStreamSource(stream);
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 1024;
    src.connect(analyser);
    dataArray = new Uint8Array(analyser.frequencyBinCount);
  }

  function getLevel(){
    if(!analyser) return 0;
    analyser.getByteTimeDomainData(dataArray);
    let sum=0;
    for(let i=0;i<dataArray.length;i++){
      const v = (dataArray[i]-128)/128; // -1~1
      sum += v*v;
    }
    const rms = Math.sqrt(sum / dataArray.length); // 0~≈0.5
    return Math.min(1, Math.max(0, (rms - 0.02) / 0.28)); // 노말라이즈
  }

  // 색 유틸
  const hexToRgb = (hex) => {
    const n = parseInt(hex.slice(1),16);
    return [(n>>16)&255, (n>>8)&255, n&255];
  };
  const lerpColor = (c1,c2,t) => c1.map((v,i)=> Math.round(v + (c2[i]-v)*t));
  const BASE_RGB   = hexToRgb(BASE_HEX);
  const ACTIVE_RGB = hexToRgb(ACTIVE_HEX);

  function drawWave(yBase, amp, alpha, phaseSpeed){
    ctx.beginPath();
    const step = 8;
    for(let x=0; x<=w; x+=step){
      const t = time*phaseSpeed + x*0.012;
      const y = yBase
              - Math.sin(t)*amp*0.9
              - Math.cos(t*0.7)*amp*0.4;
      if(x===0) ctx.moveTo(0,y); else ctx.lineTo(x,y);
    }
    ctx.lineTo(w,h); ctx.lineTo(0,h); ctx.closePath();

    // 사운드에 따라 #FFC6C6 → #FE4141 보간
    const mix = lerpColor(BASE_RGB, ACTIVE_RGB, levelSmooth);
    const top   = `rgba(${mix[0]}, ${mix[1]}, ${mix[2]}, ${alpha})`;
    const bottom= `rgba(${mix[0]}, ${mix[1]}, ${mix[2]}, 0)`;

    const grad = ctx.createLinearGradient(0, yBase - amp*2, 0, h);
    grad.addColorStop(0, top);
    grad.addColorStop(1, bottom);
    ctx.fillStyle = grad;
    ctx.fill();
  }

  function animate(){
    requestAnimationFrame(animate);
    time += 0.016;

    level = getLevel();
    levelSmooth = levelSmooth*0.85 + level*0.15; // 스무딩

    ctx.clearRect(0,0,w,h);

    const ampBoost = CONFIG.maxBoost * Math.pow(levelSmooth, 0.9);
    const yBase = h * 0.35;

    for(let i=0;i<CONFIG.layers;i++){
      const depth = i+1;
      const amp = (CONFIG.baseAmp + ampBoost*(1 - i*0.2)) * (1 - i*0.12);
      drawWave(
        yBase + depth*16,
        amp,
        CONFIG.alpha[i] || 0.35,
        CONFIG.speed[i] || 1
      );
    }
  }

  btn.addEventListener('click', async () => {
    try{
      await initMic();
      if(audioCtx && audioCtx.state === 'suspended') await audioCtx.resume();
      btn.classList.add('hide');
    }catch(e){
      alert('마이크 권한을 허용해야 비주얼이 작동합니다.');
      console.error(e);
    }
  });

  animate();
})();
</script>
</body>
</html>