<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>XROMEDA Record</title>
<style>
  :root{
    --wave-height: 34vh;
    --blur: 10px;
    --opacity: 0.95;
  }
  body{
    margin:0; min-height:100vh; background:#000; color:#fff;
    font-family: "Pretendard Variable", Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans KR", "Apple SD Gothic Neo", sans-serif;
  }
  .sound-wave-wrap{
    position:fixed; left:0; right:0; bottom:0; height:var(--wave-height);
    pointer-events:none; z-index:0;
  }
  .sound-wave{
    position:absolute; inset:0; width:100%; height:100%; display:block;
    filter: blur(var(--blur)); opacity: var(--opacity); mix-blend-mode: screen;
  }
  .btn{
    position:fixed; left:50%; transform:translateX(-50%); z-index:10;
    background:#ffffff12; color:#fff; border:1px solid #ffffff33;
    padding:10px 14px; border-radius:999px; backdrop-filter: blur(6px);
    font-weight:600; cursor:pointer;
  }
</style>
</head>
<body>

<button class="btn" id="recordBtn">🔴 녹음 시작</button>

<div class="sound-wave-wrap" aria-hidden="true">
  <canvas id="wave" class="sound-wave"></canvas>
</div>

<script>
(() => {
  /** ========= 상태/공유 변수 ========= */
  let micStream = null;          // getUserMedia로 받은 스트림(시각화/녹음 모두 재사용)
  let audioCtx = null, analyser = null, dataArray = null;
  let mediaRecorder = null, isRecording = false, audioChunks = [];

  const canvas = document.getElementById('wave');
  const ctx = canvas.getContext('2d');
  const recordBtn = document.getElementById('recordBtn');

  const CONFIG = {
    layers: 3,
    baseAmp: 22,
    maxBoost: 80,
    speed: [0.85, 1.1, 1.5],
    alpha: [0.60, 0.48, 0.38]
  };

  // 색: #FFC6C6 → #FE4141로 보간
  const BASE_HEX = "#FFFFFF";
  const ACTIVE_HEX = "#FE4141";

  /** ========= 캔버스 리사이즈 ========= */
  let w=0, h=0, time=0, level=0, levelSmooth=0;
  function resize(){
    const rect = canvas.getBoundingClientRect();
    canvas.width  = Math.ceil(rect.width * devicePixelRatio);
    canvas.height = Math.ceil(rect.height * devicePixelRatio);
    ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
    w = rect.width; h = rect.height;
  }
  addEventListener('resize', resize, {passive:true}); resize();

  /** ========= 유틸 ========= */
  const hexToRgb = (hex) => {
    const n = parseInt(hex.slice(1),16);
    return [(n>>16)&255, (n>>8)&255, n&255];
  };
  const lerpColor = (c1,c2,t) => c1.map((v,i)=> Math.round(v + (c2[i]-v)*t));
  const BASE_RGB   = hexToRgb(BASE_HEX);
  const ACTIVE_RGB = hexToRgb(ACTIVE_HEX);

  /** ========= 마이크 시각화 초기화 ========= */
  async function ensureMic(){
    if (micStream) return; // 이미 초기화됨
    micStream = await navigator.mediaDevices.getUserMedia({ audio: true });

    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const src = audioCtx.createMediaStreamSource(micStream);
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 1024;
    src.connect(analyser);
    dataArray = new Uint8Array(analyser.frequencyBinCount);
  }

  function getLevel(){
    if(!analyser) return 0;
    analyser.getByteTimeDomainData(dataArray);
    let sum=0;
    for(let i=0;i<dataArray.length;i++){
      const v = (dataArray[i]-128)/128;
      sum += v*v;
    }
    const rms = Math.sqrt(sum / dataArray.length);
    return Math.min(1, Math.max(0, (rms - 0.02) / 0.28));
  }

  function drawWave(yBase, amp, alpha, phaseSpeed){
    ctx.beginPath();
    const step = 8;
    for(let x=0; x<=w; x+=step){
      const t = time*phaseSpeed + x*0.012;
      const y = yBase - Math.sin(t)*amp*0.9 - Math.cos(t*0.7)*amp*0.4;
      if(x===0) ctx.moveTo(0,y); else ctx.lineTo(x,y);
    }
    ctx.lineTo(w,h); ctx.lineTo(0,h); ctx.closePath();

    const mix = lerpColor(BASE_RGB, ACTIVE_RGB, levelSmooth);
    const top   = `rgba(${mix[0]}, ${mix[1]}, ${mix[2]}, ${alpha})`;
    const bottom= `rgba(${mix[0]}, ${mix[1]}, ${mix[2]}, 0)`;

    const grad = ctx.createLinearGradient(0, yBase - amp*2, 0, h);
    grad.addColorStop(0, top);
    grad.addColorStop(1, bottom);
    ctx.fillStyle = grad;
    ctx.fill();
  }

  function animate(){
    requestAnimationFrame(animate);
    time += 0.016;

    level = getLevel();
    levelSmooth = levelSmooth*0.85 + level*0.15;

    ctx.clearRect(0,0,w,h);

    const ampBoost = CONFIG.maxBoost * Math.pow(levelSmooth, 0.9);
    const yBase = h * 0.35;

    for(let i=0;i<CONFIG.layers;i++){
      const depth = i+1;
      const amp = (CONFIG.baseAmp + ampBoost*(1 - i*0.2)) * (1 - i*0.12);
      drawWave(
        yBase + depth*16,
        amp,
        CONFIG.alpha[i] || 0.35,
        CONFIG.speed[i] || 1
      );
    }
  }
  animate();

  /** ========= 버튼 핸들러 ========= */

  recordBtn.addEventListener('click', async () => {
    try{
      // 비주얼 시작 안 한 상태에서도 녹음 버튼만 눌러도 동작하도록
      await ensureMic();

      if (!isRecording) {
        // 녹음 시작 (기존 micStream 재사용)
        const mime = MediaRecorder.isTypeSupported('audio/webm;codecs=opus')
          ? 'audio/webm;codecs=opus' : 'audio/webm';
        mediaRecorder = new MediaRecorder(micStream, { mimeType: mime });
        audioChunks = [];
        mediaRecorder.ondataavailable = (e) => { if (e.data.size) audioChunks.push(e.data); };
        mediaRecorder.onstop = () => {
          const blob = new Blob(audioChunks, { type: mime });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `vrook_record_${new Date().toISOString().replace(/[:.]/g,'-')}.webm`;
          a.click();
          URL.revokeObjectURL(url);
        };
        mediaRecorder.start();
        isRecording = true;
        recordBtn.textContent = '⏹️ 녹음 정지';
      } else {
        // 녹음 종료
        mediaRecorder.stop();
        isRecording = false;
        recordBtn.textContent = '🔴 녹음 시작';
      }
    }catch(e){
      alert('녹음을 시작할 수 없습니다. 권한 또는 장치를 확인해주세요.');
      console.error(e);
    }
  });
})();
</script>
</body>
</html>
